# SOF


[2021-09-13.00]
Workarounds for cores produced by wrong settings of Dot-Ofsset (w_doto, b_doto)
outside of the current line.


Reproducing the error:

(1) Fill Paragraph (Esc-q)

(2) Undo (Ctrl+Shift+_)

This confuses the doto settings: Microemacs always assumes 0 <= doto <= l_used.

With -DJES_UNSEC_CODE the errors could be reproduced.

Furthermore fill-paragraph does not work correctly e.g. when used in som TeX-documents.


[2021-10-05.00]

Next steps to repair the (w|b)_doto-Problem:

(1) Introduce (get|set)_(b|w)_doto Makros and use the througout the code: Done.

(2) Test uemacs with this modification: Done.

(3) Fix wrong (w|b)_doto-Settings in the (get|set)_(b|w)_doto Macros and trace wrong settings: Done.

(4) Check that TRC in line.c isn't triggered any more: Done.

(5) Remove Fix and TRC in line.c: Done.

(6) Enable the other platforms: Done

(7) Introduce get/set-Logic and repair-code of the dot-code for the mark code as well: Might be unneccesary

(8) FIX THIS ERROR: `TRC (../src/undo.c/131): set_w_doto(): Too large doto: 156. REWRITTEN TO: 155.'
    - This seems to be an error in the fillpara function in word.c
    - Introduced the trParFill() in random.c which is an unduable replacement.
    Done

(9) The "indent-region" function is also undoable: Must be repaired: Done.

(10) Introduce a goto(b|e)ofrp(): Goto(Beginning|End)ofRawParagraph and
     a trRParFill(): Raw paragraphs are limited by '\r' only. DONE: Not
     necessary, simply set the environment variable $wchars to a string
     containing all charcters thet will be recogbnized as parts of
     words, e.g.:

    set $wchars "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+{}[]\\|;:\"'<>,./?~`"

===>

(11) _goto-eop goes to the end of the next paragrapg, when point is at
    the last letter of a paragraph:

    lastword.   or   lastword
           ^                ^

(12) Make filter-buffer redoable and introduce filter-region.


[2021-11-07.00]

The automatic reformatting has destroyed some of the very nice formatted
comments in the original code: This has to be recreated!

These files have been reviewed:

File Name     Formated Comments   Func. Proto.    Init.   Warnings  EOF
============================================================================
src/bind.c      X                   X                       X         X
src/exec.c      X                   X               X       X         X
src/display.c   X                   X                       X         X
src/eval.c      X                   X                       X         X
src/file.c      X                   X                       X         X
src/ibmpc.c     X                   X               X       X         X
src/input.c     X                   X               X       X         X
src/isearch.c   X                   X               X       X         X
src/keyboard.c  X                   X               X       X         X
src/line.c      X                   X               X       X         X
src/lock.c      X                   X               X       X         X
src/main.c      X                   X                       X         X
src/mouse.c     X                   X                       X         X
src/msdos.c     X                   X               X       X         X
src/random.c    X                   X                       X         X
src/replace.c   X                   X                       X         X
src/screen.c    X                   X                       X         X
src/search.c    X                   X                       X         X
src/unix.c      X                   X                       X         X
h/edef.h        X                                                     X
h/eproto.h      X                                                     X
h/estruct.h     X                                                     X
h/mswin.h       X                                                     X


[2023-07-13.00]
- Substitute `void *' with VOIDP  (\/)
- edef.h nachschauen: Das wird in search.c verwendet: Ist da signed/unsigned wichtig?   (\/)
- Fix compiler warnings.          (\/)
- Compiles without warnings on linux (gcc), FreeBSD (clan, gcc), OpenBSD (clang),
  Solaris SPARC (gcc)             (\/)
- static returned buffer in eval.c:gtfun()  (\/)
- Macro ISSPACE                   (\/)
- replace *all* estruct.h files   (\/)
- Include Martin Vorlaender's VMS changes:
  + file.c:getfile(): Do a strdup of `fname'
  + smg.c:            Reformat.
  + vms.c:            Reformat.
  + The functions grabnowait(), grabwait() added to eproto.h have
    different return types (int / unsigned char) for different
    platforms: This is an *error* which needs to be fixed.
- continue in:
  + Comments
  + PCDOS with Borland C++: issue with help-system:
    - Call help
    - Use arrow key
    - You are catched in a macro-loop
    - Does not occur on MicroEmacs 4.0
    - We test these versions:

      (a) ue400dev.zip (2005)
      (b) emacs5.zip (2009): Daniel_Michael_Lawrence/http:@@www.aquest.com/downloads
      (c) https:@@github.com@pmachapman@memacs.tar.xz --- pmachapman.zip (2018)
      (d) master.zip: Archive created out of the current (2023-07-19) master branch.

      Version (c) Seems to be younger than Version (b).

      ( i)  (a): The Error does not occur.
      (ii)  (c): Compiled with a modified (a) estruct.h: The error does
                not occur.
      (iii) (d): Compiled with a modified (a) estruct.h: The error does
                not occur.

    - The error can be reproduced on UNIX(FreeBSD): it occurs in branch
      "fixes" but not in branch "master")

      Next step: ?Bisecvtion in "fixes".

    - emacs.fixes_2023-04-03_GOOD
      emacs.fixes_2023-07-13_BAD

      commit a15abcc4adcb9958f047a7fc023ce6e920ffdaeb
      Author: Dr. Joachim Schneider <jesmx@hal.rhein-neckar.de>
      Date:   Thu Jul 13 19:39:27 2023 +0200

        Removed all warnings.

      commit 869090a8fd95b287b433d0077b7c088c54635ed1
      Author: Dr. Joachim Schneider <jesmx@hal.rhein-neckar.de>
      Date:   Mon Apr 3 11:37:56 2023 +0200

        Ich bin gerade am reparieren, will den derzeitigen Stand aber sichern.

    - Regression found:

      $ git diff ../src/eval.c
      diff --git a/ue500/src/eval.c b/ue500/src/eval.c
      index 0854636..00d23f5 100644
      --- a/ue500/src/eval.c
      +++ b/ue500/src/eval.c
      @@ -81,9 +81,9 @@ CONST char  *fname;     /* name of function to evaluate */
           register int  arg     = 0;          /* value of some arguments    */
           BUFFER        *bp     = NULL;       /* scratch buffer pointer     */
           /* ==== These might be part of the (static allocated) result ==== */
      -    static char   arg1[NSTRING];        /* value of first argument    */
      -    static char   arg2[NSTRING];        /* value of second argument   */
      -    static char   arg3[NSTRING];        /* value of third argument    */
      +    char          arg1[NSTRING];        /* value of first argument    */
      +    char          arg2[NSTRING];        /* value of second argument   */
      +    char          arg3[NSTRING];        /* value of third argument    */
           static char   result[2 * NSTRING];  /* string result              */
           /* ============================================================== */

[2023-07-20.00]
New TODO's
* Check eval.c:gtfun(): why arg{1,2,3} must not be static.  (\/)
* Why has the size grown so much:
  548512 emacs.fixes_2023-04-03_GOOD
  840016 emacs.fixes_2023-07-13_BAD
  ===> The main difference seem to be that we initialize much more
       function local variables.

[2023-07-26.00]
* pcdos/turbo: Still does not work:
  - After using help system emacs hangs.

[2023-07-27.00]
* Test New String Functions: ../Temp/NewStringFunctions/random.c  ) (\/)
  ===> Switched to the new simplified versions now.
* Test DOS-Version after rval hide has been resolved                (\/)
  ===> Problem is still there.
* Check all static returns in eval.c

[2023-07-28.00]
Status of pcdos/turbo error, which is reproduced on DOS by
o set HOME=<Path To CMD folder>
o Start emacs
o Start Help System
o Navigate around
o Leave Help System: Now emacs hangs.

- It exists on DOSEMU and on DOSBOX.
- It does *not* occur with UE312DEV.
- It occurs on UE400DEV and later.
- Does it depend on the macros in CMD folder?

+ It does *not* occur on UE400DEV when using the *original* estruct.h:
  In the previous experiments we used a modified PMACHAPMAN estruct.h

+ They differ in

  BAD:
    NLINE   = 512
    NSTRING = 512
    NPAT    = 512

  GOOD:
    NLINE   = 256
    NSTRING = 128
    NPAT    = 128

+ With these settings the *latest* UE500DEV (i.e. UE230728) works!

+ This strongly suggests, that there is a memory overwrite caused by
  use of *unsafe* library functions like (x)strcpy and sprintf.


[2023-07-28.00]

Number of strcpy:   457
Number of sprintf:  25

Plan:

- We repair the sprintf's manually by substituting them with xsnprintf's whereever possible.

- We introduce an XSTRCPY - Macro which is substituded for xstrcpy:

  /* SFSTRCPY:
   *  if size .GE. 0 copy src to dst usling xstrlcpy(dst, src, sizeof(dst))
   *  else           copy src to dst usling xstrcpy(dst, src) and log
   *                 a warning message.
   */
  extern char *sfstrcpy_(char *dst, int dst_size, const char *src, const char *file, int line);

#define XSTRCPY(dst, src)  sfstrcpy_((dst), IS_ARRAY((dst)) ? sizeof((dst)) : (-1), (src), __FILE__, __LINE__)

- Some occurances of xstrcpy can't be replaced by XSTRCPY because dst
  is not an Lvalue: We use xstrcpy there:
  ===> These must be reviewed.

- Handle bytecopy: Is safe but might be expressed with strlcpy

- Handle strcat: Replace strcat by XSTRCAT.


[2023-07-30.00]

Next steps to handle the (hidden) overwrite:

- Substitute strcat by xstrcat: Overlapping regions are OK                (\/)

- Substitute xstrcat by XSTRCAT.                                          (\/)

- XSTRCPY and XSTRCAT generate tarce warnings ... unsafe ... when dst in
  not an array: Sustitute these occurances with xstrcpy and xstrcat.      (\/)

- Replace --- if possible --- `strncat' by `strlcat'.

- *Manually* analyze the remaining `sprintf', `xstrcpy' and `xstrcat'
  occurances.

- Manually check *all* occurences of XSTR{CPY,CAT} in the OS-Dependent
  modules like

  vms.c, os2.c, aosvs.c ,nt.c amigados.c, ...

  Workaround: Substitute the lower case versions there, to not
  produce broken code.                                                    (\/)

- Remove *all* warnings in msdos.c and ibmpc.c                            (\/)

- Initialize *all* variables in msdos.c and ibmpc.c                       (\/)
  ===> Did not help

- Bisect the F10 handler in ehelp.cmd

- Repair all doubtful statically returned strings in eval.c (the macro
  processing module) by optionally introducing the static stacks.

- From step to step check with PCDOS/TURBO build.


The error is still there and it is an overwrite:

TRC (..\..\src\line.c/305): lgetcp_(): Read at Buffer Boundry: l_size_ = 64, l_used_ = 54, l_text_[54] = ' '
TRC (..\..\src\line.c/305): lgetcp_(): Read at Buffer Boundry: l_size_ = 64, l_used_ = 55, l_text_[55] = ' '
TRC (..\..\src\line.c/305): lgetcp_(): Read at Buffer Boundry: l_size_ = 64, l_used_ = 56, l_text_[56] = ' '
TRC (..\..\src\display.c/827): lp->l_used_ = -1822, lp->lsize_ = -22013
File: ..\..\src\display.c, Line: 827
	Assertion `lp->l_used_ <= lp->l_size_' failed!
OS: `Invalid argument
'
--- abort ...


[2023-07-30.01]
The overwrite is not observalble if we set NSTRING from 512 down to 128
(the previous UE312 value).

- Additional steps:
  + Check if reducing NSTRING in msdos.c only eliminates the error:
    ===> NO


[2023-07-31.00]

* Indeed the DOS-Error is there since (at least) UE212: Redefining
  NSTRING from 128 to 512 in estruct.h reproduces the error!

* The Error does not vanish when one comments out the VGA/EGA related
  code in the EHELP.CMD.


[2023-08-01.00]

DOS-Error: SOLVED! It is a Stack Overflow!

* Enlardged NSTRING to 16834, compliled on Linux run it under
  `valgrind': No Problems

* Set the `-N' flag in the compile staement inside the makefile (before
  it was `-N-': Switch off stack checking).

  Compiled an run UE312 with

  - NSTRING = 512:  Stack Overflow
  - NSTRING = 128:  No Error --- everything is OK


[2023-08-01.01]

Next Steps:

- Repair all doubtful statically returned strings in eval.c (the macro
  processing module) by optionally introducing the static stacks.
  ===> Not solved in this way instead using STATIC_STR_RET-Macros (\/)

- Implement xstrdup with the function already available           (\/)

- Substitute `free' with `FREE'

- Check modifications in DOS-Compile:                             (\/)
  + ctime()
  + strrev()

- Handle bytecopy: Is safe but might be expressed with strlcpy    (\/)

- Do an `#ifdef MSDOS' or somehow increase the Stack-Size in DOS. (\/)

  BAD:
    NLINE   = 512
    NSTRING = 512
    NPAT    = 512

  GOOD:
    NLINE   = 256
    NSTRING = 128
    NPAT    = 128

- Reduce the size of the buffer for ctime() in msdos,c (it was    (\/)
  increased from 16 to 256 for debugging purposes).


[2023-08-06.00]
Next Steps:
- msdos.c and ibmpc.c: Check comments.                            (\/)
- Check if `PASCAL NEAR' reduces pcdos/turbo code size            (\/)
  ===> Yes, but only about 2500 bytes.
- Check *all* well formatted special comments.
- Build on AIX
- Build on Windows XP.
- Substitute `free' with `FREE'
- Replace --- if possible --- `strncat' by `strlcat'.
- *Manually* analyze the remaining `sprintf', `xstrcpy' and `xstrcat'
  occurances.
- Build with C++-Compiler on
  + MSDOS                                                         (\/)
  + FreeBSD
  + Linux
- Identify functions which could be declared module local (`static')
- Sort eproto.h declarations and add platform specific sections therein.


[2023-08-08.00]

<http://odl.sysworks.biz/disk$axpdocjun032/progtool/cpqc65/5492p017.htm>

4.4 Storage-Class Modifiers

Compaq C for OpenVMS Systems provides support for the storage-class
modifiers noshare , readonly , and _align as VAX C keywords. The
recognition of these three storage-class modifiers as keywords (along
with the other VAX C specific keywords) is controlled by a combination
of the compiler mode and the /ACCEPT command-line qualifier. The
default behavior on OpenVMS systems is for the compiler to recognize
these storage-class modifiers as keywords in the VAX C compatibility
mode and relaxed ANSI C mode (assuming that /ACCEPT=NOVAX_KEYWORDS is
not also specified.) Conversely, they are not recognized by default in
all other modes unless overridden by /ACCEPT=VAX_KEYWORDS.

Compaq C also provides the __inline , __forceinline and __align
storage-class modifiers. These are recognized as valid keywords in all
compiler modes on all platforms. They are in the namespace reserved to
the C implementation, so it is not necessary to allow them to be
treated as user-declared identifiers. They have the same effects on all
platforms, except that on OpenVMS VAX systems, the __forceinline
modifier does not cause any more inlining than the __inline modifier
does.

Compaq C also provides the inline storage-class modifier. This modifier
is supported in relaxed ANSI C mode (/STANDARD=RELAXED_ANSI89) or if
the /ACCEPT=C99_KEYWORDS or /ACCEPT=GCCINLINE qualifier is specified.

For additional information about the __inline , __forceinline , __align
, and inline storage-class modifiers, see the Compaq C Language
Reference Manual.

You can use a storage-class specifier and a storage-class modifier in
any order; usually, the modifier is placed after the specifier in the
source code. For example:


extern  noshare  int  x;

   /*  Or, equivalently...*/

int  noshare  extern  x;

The following sections describe each of the Compaq C storage-class
modifiers.

4.4.1 The noshare Modifier

The noshare storage-class modifier assigns the attribute NOSHR to the
program section of the variable. Use this modifier to allow other
programs, used as shareable images, to have a copy of the variable's
psect without the shareable images changing the variable's value in the
original psect.

When a variable is declared with the noshare modifier and a shared
image that has been linked to your program refers to that variable, a
copy is made of the variable's original psect to a new psect in the
other image. The other program may alter the value of that variable
within the local psect without changing the value still stored in the
psect of the original program.

For example, if you need to establish a set of data that will be used
by several programs to initialize local data sets, then declare the
external variables using the noshare specifier in a Compaq C program.
Each program receives a copy of the original data set to manipulate,
but the original data set remains for the next program to use. If you
define the data as extern without the noshare modifier, a copy of the
psect of that variable is not made; each program would be allowed
access to the original data set, and the initial values would be lost
as each program stores the values for the data in the psect. If the
data is declared as const or readonly , each program is able to access
the original data set, but none of the programs can then change the
values.

You can use the noshare modifier with the static , extern , globaldef ,
and globaldef {"name"} storage-class specifiers. For more information
about the possible combinations of specifiers and modifiers, and the
effects of the storage-class modifiers on program-section attributes,
see Section 4.8.

You can use noshare alone, which implies an external definition of
storage class extern . Also, when declaring variables using the extern
and globaldef {"name"} storage-class specifiers, you can use noshare ,
const , and readonly , together, in the declaration. If you declare
variables using the static or the globaldef specifiers, and you use
both of the modifiers in the declaration, the compiler ignores noshare
and accepts const or readonly .

4.4.2 The readonly Modifier

The readonly storage-class modifier, like the const data-type
qualifier, assigns the NOWRT attribute to the variable's program
section; if used with the static or globaldef specifier, the variable
is stored in the $CODE psect, which has the NOWRT attribute by default.

You can use both the readonly and const modifiers with the static ,
extern , globaldef , and globaldef {"psect"} storage-class specifiers.

In addition, both the readonly modifier and the const modifier can be
used alone. When you specify these modifiers alone, an external
definition of storage class extern is implied.

The const modifier restricts access to data in the same manner as the
readonly modifier. However, in the declaration of a pointer, the
readonly modifier cannot appear between the asterisk and the pointer
variable to which it applies.

The following example shows the similarity between the const and
readonly modifiers. In both instances, the point variable represents a
constant pointer to a nonconstant integer.


readonly int * point;

int * const point;

Note

For new program development, DIGITAL recommends that you use the const
modifier, because const is ANSI C compliant and readonly is not.


[2023-08-09.00]
[2023-08-10.00]
[2023-08-11.00]
[2023-08-12.00]
[2023-08-13.00]


Next Steps

(A) Allow to compile with C++ for improved compiler checks:

    + foreach file needed to compile on UNIX, MSDOS, VMS do
        - Convert all K&R definitions to the P#_-Format (which
          expands to ANSI-C definitions with PROTO set.).
        - While reviewing the files repair broken comments
        - Current File is: src/unix.c
      done

    + #define SIZEOF(x) ( (int)sizeof((x)) )
      Substitute sizeof ---> SIZEOF in *all* files

    + Remove all other C++ Warnings

(B) Create a simple C-program to extract comments out of ANSI-C files.
    Sample output:

    --------------------------------------------------------------------
    Comment Nr ####, File: ##########, Line: ####
    --------------------------------------------------------------------
    /* This is a sample comment
          */
    --------------------------------------------------------------------

    Use this program to check all comments of the files processed in (A).

    Repair the comments in all remaining files.


(C) Additionally:

    - Check the execprog definitions:

      ue500/src/fmrdos.c:PASCAL NEAR execprog(cmd)
      ue500/src/msdos.c:static int PASCAL NEAR execprog P1_(CONST char *, cmd)
      ue500/src/necdos.c:PASCAL NEAR execprog(cmd)
      ue500/src/nt.c:execprog(char *cmd)
      ue500/src/os2.c:execprog(char *cmd)
      ue500/src/xp.c:execprog(char *cmd)
      ue500/src/xvtdos.c:int PASCAL NEAR execprog(cmd)

    - Re-Check the int/char case with VMS

# EOF
