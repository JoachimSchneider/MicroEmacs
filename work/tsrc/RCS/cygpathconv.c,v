head	1.6;
access;
symbols;
locks
	joachim:1.6; strict;
comment	@ * @;


1.6
date	2024.02.14.13.01.33;	author joachim;	state Exp;
branches;
next	1.5;

1.5
date	2024.02.14.12.18.28;	author joachim;	state Exp;
branches;
next	1.4;

1.4
date	2024.02.12.20.08.01;	author joachim;	state Exp;
branches;
next	1.3;

1.3
date	2024.02.12.20.02.59;	author joachim;	state Exp;
branches;
next	1.2;

1.2
date	2024.02.11.21.14.17;	author joachim;	state Exp;
branches;
next	1.1;

1.1
date	2024.02.11.17.44.02;	author joachim;	state Exp;
branches;
next	;


desc
@@


1.6
log
@*** empty log message ***
@
text
@#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include <stdlib.h>


#define REGISTER    register
#define ASRT        assert
#define SIZEOF(x)   ( (int)sizeof(x) )
#define NFILEN      (255)
#define ZEROMEM(x)  ( memset(&(x), 0, SIZEOF(x)) )
#define ISALPHA     isalpha
#define ISSPACE     isspace
#define CONST       const
#define xsnprintf   snprintf
#define xstrlcpy(dst, src, dstsiz)  ( strcpy((dst), (src)) )
#define CASRT(x)


int xstrcasecmp(const char *s1, const char *s2)
{
    REGISTER int  i = 0;

    ASRT(NULL != s1);
    ASRT(NULL != s2);

# define us1_ ( (unsigned char *)s1 )
# define us2_ ( (unsigned char *)s2 )

    for ( i = 0; ; i++ )  {
        REGISTER int  c1  = '\0';
        REGISTER int  c2  = '\0';
        REGISTER int  lc1 = '\0';
        REGISTER int  lc2 = '\0';

        c1  = us1_[i];
        c2  = us2_[i];
        lc1 = tolower(c1);
        lc2 = tolower(c2);
        if ( '\0' == c1 || '\0' == c2 || lc1 != lc2 ) {
            return ( lc1 - lc2 );
        }
    }
# undef us1_
# undef us2_
}

int xstrncasecmp(const char *s1, const char *s2, int len)
{
    REGISTER int  i = 0;

    ASRT(NULL != s1);
    ASRT(NULL != s2);
    ASRT(0    <= len);

# define us1_ ( (unsigned char *)s1 )
# define us2_ ( (unsigned char *)s2 )

    for ( i = 0; i < len; i++ ) {
        REGISTER int  c1  = '\0';
        REGISTER int  c2  = '\0';
        REGISTER int  lc1 = '\0';
        REGISTER int  lc2 = '\0';

        c1  = us1_[i];
        c2  = us2_[i];
        lc1 = tolower(c1);
        lc2 = tolower(c2);
        if ( '\0' == c1 || '\0' == c2 || lc1 != lc2 ) {
            return ( lc1 - lc2 );
        }
    }

    return ( 0 );
# undef us1_
# undef us2_
}

int strcasestart(const char *start, const char *test)
{
    REGISTER int  slen  = 0;
    REGISTER int  tlen  = 0;

    ASRT(NULL != start);
    ASRT(NULL != test);

    slen  = strlen(start);
    tlen  = strlen(test);

    if ( tlen < slen )  {
        return ( 0 );
    } else              {
        return ( 0 == xstrncasecmp(start, test, slen) );
    }
}


/*====================================================================*/

static CONST char *wingetshell(void)
{
    static char res[NFILEN];

    ZEROMEM(res);

    xsnprintf(res, SIZEOF(res), "%s", "C:\\Windows\\system32\\cmd.exe");

    return res;
}

#define TO_DOS_SEP_(x)  do  {                   \
    unsigned char *cp__ = (unsigned char *)(x); \
    unsigned char c__   = '\0';                 \
                                                \
    while ( ( c__ = *cp__) )  {                 \
        if ( '/' == c__ ) {                     \
            *cp__ = '\\';                       \
        }                                       \
        cp__++;                                 \
    }                                           \
} while ( 0 )

#define TO_UNX_SEP_(x)  do  {       \
    unsigned char *cp__ = (unsigned char *)(x); \
    unsigned char c__   = '\0';                 \
                                                \
    while ( ( c__ = *cp__) )  {                 \
        if ( '\\' == c__ )  {                   \
            *cp__ = '/';                        \
        }                                       \
        cp__++;                                 \
    }                                           \
} while ( 0 )

const char *absdos2unxpath_(const char *dos)
{
#define CYGDRIVE_       "/cygdrive/"
#define CYGDRIVE_LEN_   ( SIZEOF(CYGDRIVE_) - 1 )
    unsigned char in[NFILEN];
    static char   res[NFILEN];
    int           len = 0;
    int           drv = '\0';

    ASRT(NULL != dos);
    ZEROMEM(in);
    ZEROMEM(res);

    xstrlcpy((char *)in, dos, SIZEOF(in));
    TO_DOS_SEP_(in);
    len = strlen((CONST char *)in);

    if ( 2 <= len && ':' == in[1] && ISALPHA(drv = in[0]) ) {
        int i = 2;
        int j = CYGDRIVE_LEN_;

        drv = tolower(drv);
        strcpy(res, CYGDRIVE_);
        res[j++]  = drv;
        if ( 2 == len ) {
            return res;
        }
        res[j++]  = '/';
        if ( '\\' == in[i] )  {
            i++;
        }
        for ( ; i < len && j < SIZEOF(res) - 1; i++, j++ )  {
            if ( '\\' == in[i] )  {
                res[j]  = '/';
            } else                {
                res[j]  = in[i];
            }
        }
        
    }

    return res;
# undef CYGDRIVE_LEN_
# undef CYGDRIVE_
}

const char  *cygrootdos(void)
{
    static int  FirstCall = !0;
    static char res[NFILEN];

    if ( FirstCall )  {
        int                 c             = '\0';
        FILE                *pp           = NULL;
        CONST char          *unxwinshell  = NULL;
        char                cmd[NFILEN];
        char                doscygroot[NFILEN];
        enum { start, get } state         = start;
        int                 i             = 0;

        ZEROMEM(cmd);
        ZEROMEM(doscygroot);

        unxwinshell = absdos2unxpath_(wingetshell());
        xsnprintf(cmd, SIZEOF(cmd), "( cd / && %s /c cd )", unxwinshell);
        if ( NULL != (pp = popen(cmd, "r")) ) {
            while ( EOF != (c = fgetc(pp)) )  {
                if ( state == start && ISSPACE(c) ) {
                    continue;
                }
                state = get;
                if ( i >= SIZEOF(res) - 1 )   {
                    break;
                }
                if ( '\n' == c || '\r' == c ) {
                    break;
                }
                res[i++]  = c;
            }
            pclose(pp);
        }
        
        FirstCall = 0;
    }

    return res;
}

const char  *cygrootunx(void)
{
    static int  FirstCall = !0;
    static char res[NFILEN];

    if ( FirstCall )  {
        xsnprintf(res, SIZEOF(res), "%s", absdos2unxpath_(cygrootdos()));
    }
    
    return res;
}

const char  *cygpwddos(void)
{
    static char res[NFILEN];

    int                 c             = '\0';
    FILE                *pp           = NULL;
    CONST char          *unxwinshell  = NULL;
    char                cmd[NFILEN];
    char                doscygroot[NFILEN];
    enum { start, get } state         = start;
    int                 i             = 0;

    ZEROMEM(cmd);
    ZEROMEM(doscygroot);

    unxwinshell = absdos2unxpath_(wingetshell());
    xsnprintf(cmd, SIZEOF(cmd), "( %s /c cd )", unxwinshell);
    if ( NULL != (pp = popen(cmd, "r")) ) {
        while ( EOF != (c = fgetc(pp)) )  {
            if ( state == start && ISSPACE(c) ) {
                continue;
            }
            state = get;
            if ( i >= SIZEOF(res) - 1 )   {
                break;
            }
            if ( '\n' == c || '\r' == c ) {
                break;
            }
            res[i++]  = c;
        }
    pclose(pp);
    }

    return res;
}

const char  *cygpwdunx(void)
{
    static int  FirstCall = !0;
    static char res[NFILEN];

    if ( FirstCall )  {
        xsnprintf(res, SIZEOF(res), "%s", absdos2unxpath_(cygpwddos()));
    }
    
    return res;
}

int cygdrvdos(void)
{
    return (unsigned char)cygpwddos()[0];
}


const char *dos2unxpath(const char *dos)
{
#define CYGDRIVE_       "/cygdrive/"
#define CYGDRIVE_LEN_   ( SIZEOF(CYGDRIVE_) - 1 )
    unsigned char in[NFILEN];
    static char   res[NFILEN];
    int           len = 0;

    ASRT(NULL != dos);
    ZEROMEM(in);
    ZEROMEM(res);

    xstrlcpy((char *)in, dos, SIZEOF(in));
    TO_DOS_SEP_(in);
    len = strlen((CONST char *)in);
    if ( 2 <= len && ':' == in[1]  && ISALPHA(in[0]) )  {
         xstrlcpy(res, absdos2unxpath_((CONST char *)in), SIZEOF(res));
    } else {
        char xpath[NFILEN];

        ZEROMEM(xpath);
        
        if ( '\\' == in[0] )  {
            xsnprintf(xpath, SIZEOF(xpath), "%c:%s", cygdrvdos(), in);
        } else                {
            xsnprintf(xpath, SIZEOF(xpath), "%s\\%s", cygpwddos(), in);
        }
        xstrlcpy(res, absdos2unxpath_(xpath), SIZEOF(res));
    }

    return res;
# undef CYGDRIVE_LEN_
# undef CYGDRIVE_
}

const char *absunx2dospath_(const char *unx)
{
#define CYGDRIVE_       "/cygdrive/"
#define CYGDRIVE_LEN_   ( SIZEOF(CYGDRIVE_) - 1 )
    unsigned char in[NFILEN];
    static char   res[NFILEN];
    int           len = 0;
    int           drv = '\0';

    ASRT(NULL != unx);

    ZEROMEM(in);
    ZEROMEM(res);

    xstrlcpy((char *)in, unx, SIZEOF(in));
    TO_UNX_SEP_(in);
    len = strlen((CONST char *)in);
    if ( strcasestart(CYGDRIVE_, (CONST char *)in)                    &&
         CYGDRIVE_LEN_  < len                                         &&
         ISALPHA(drv = in[CYGDRIVE_LEN_])                             &&
         (CYGDRIVE_LEN_ + 1 == len || '/' == in[CYGDRIVE_LEN_ + 1])
        )   {
        int i = 0;
        int j = 0;

        drv = toupper(drv);
        res[0]  = drv;
        res[1]  = ':';
        res[2]  = '\\';
        i = CYGDRIVE_LEN_ + 1;
        j = CYGDRIVE_LEN_ + 1 == len ? 3 : 2;
        for ( ; i < len && j < SIZEOF(res) - 1; i++, j++ )  {
            if ( '/' == in[i] ) {
                res[j]  = '\\';
            } else              {
                res[j]  = in[i];
            }
        }
    }

    return res;
# undef CYGDRIVE_LEN_
# undef CYGDRIVE_
}

const char *unx2dospath(const char *unx)
{
#define CYGDRIVE_       "/cygdrive/"
#define CYGDRIVE_LEN_   ( SIZEOF(CYGDRIVE_) - 1 )
    unsigned char in[NFILEN];
    static char   res[NFILEN];
    int           len = 0;
    int           drv = '\0';

    ASRT(NULL != unx);

    ZEROMEM(in);
    ZEROMEM(res);

    xstrlcpy((char *)in, unx, SIZEOF(in));
    TO_UNX_SEP_(in);
    len = strlen((CONST char *)in);
    
    if ( strcasestart(CYGDRIVE_, (CONST char *)in)                    &&
         CYGDRIVE_LEN_  < len                                         &&
         ISALPHA(drv = in[CYGDRIVE_LEN_])                             &&
         (CYGDRIVE_LEN_ + 1 == len || '/' == in[CYGDRIVE_LEN_ + 1])
        )   {
        xstrlcpy(res, absunx2dospath_((CONST char *)in), SIZEOF(res));
    } else {
        char  xpath[NFILEN];

        ZEROMEM(xpath);

        if ( in[0] == '/' ) {
            xsnprintf(xpath, SIZEOF(xpath), "%s%s",  cygrootunx(), in);
        } else                {
            xsnprintf(xpath, SIZEOF(xpath), "%s/%s", cygpwdunx(),  in);
        }
        xstrlcpy(res, absunx2dospath_(xpath), SIZEOF(res));
    }

    return res;
# undef CYGDRIVE_LEN_
# undef CYGDRIVE_
}


int main(int argc, char *argv[])
{
  ASRT(2 == argc);

  fprintf(stdout, "===> %s <<\n", unx2dospath(argv[1]));
  fprintf(stdout, "===> %s <<\n", dos2unxpath(argv[1]));

  return 0;
}


/* EOF */
@


1.5
log
@*** empty log message ***
@
text
@d207 1
a207 1
                if ( i >= SIZEOF(res) - 1 ) {
d210 1
a210 1
                if ( '\n' == c )  {
d259 1
a259 1
            if ( i >= SIZEOF(res) - 1 ) {
d262 1
a262 1
            if ( '\n' == c )  {
@


1.4
log
@*** empty log message ***
@
text
@d14 5
d20 1
d99 3
a101 1
const char *unx2dospath(const char *unx)
d103 35
d140 4
a143 3
    static char res[NFILEN + 1];
    int         len = 0;
    int         drv = '\0';
d145 190
d337 1
d340 4
a343 2
    len = strlen(unx);
    if ( strcasestart(CYGDRIVE_, unx)                                 &&
d345 2
a346 2
         ISALPHA(drv = ((unsigned char *)unx)[CYGDRIVE_LEN_])         &&
         (CYGDRIVE_LEN_ + 1 == len || '/' == unx[CYGDRIVE_LEN_ + 1])
d358 1
a358 1
            if ( '/' == unx[i] )  {
d360 2
a361 2
            } else                {
                res[j]  = unx[i];
a363 10
    } else {
        int i = 0;

        for ( i = 0; i < len && i < SIZEOF(res) - 1; i++ )  {
            if ( '/' == unx[i] )  {
                res[i]  = '\\';
            } else                {
                res[i]  = unx[i];
            }
        }
d371 1
a371 1
const char *dos2unxpath(const char *dos)
d375 4
a378 3
    static char res[NFILEN + 1];
    int         len = 0;
    int         drv = '\0';
d380 3
a382 1
    ASRT(NULL != dos);
d385 10
a394 23
    len = strlen(dos);
    if ( 2 <= len && ':' == dos[1]  &&
         ISALPHA(drv = ((unsigned char *)dos)[0]) )   {
        int i = 2;
        int j = CYGDRIVE_LEN_;

        drv = tolower(drv);
        strcpy(res, CYGDRIVE_);
        res[j++]  = drv;
        if ( 2 == len ) {
            return res;
        }
        res[j++]  = '/';
        if ( '\\' == dos[i] || '/' == dos[i] )  {
            i++;
        }
        for ( ; i < len && j < SIZEOF(res) - 1; i++, j++ )  {
            if ( '\\' == dos[i] ) {
                res[j]  = '/';
            } else                {
                res[j]  = dos[i];
            }
        }
d396 1
a396 1
        int i = 0;
d398 6
a403 6
        for ( i = 0; i < len && i < SIZEOF(res) - 1; i++ )  {
            if ( '\\' == dos[i] ) {
                res[i]  = '/';
            } else                {
                res[i]  = dos[i];
            }
d405 1
d412 1
@


1.3
log
@*** empty log message ***
@
text
@d21 1
a21 1
  
d30 1
a30 1
        
d50 1
a50 1
  
d59 1
a59 1
        
d198 1
a198 1
  
d203 1
a203 1
}  
@


1.2
log
@*** empty log message ***
@
text
@d95 1
a95 1
#define CYGDRIVE_       "/CYGDRIVE/"
d144 51
d200 1
@


1.1
log
@Initial revision
@
text
@d95 2
a96 1
#define CYG_DRIVE_  "/CYGDRIVE/"
d106 5
a110 5
    if ( strcasestart(CYG_DRIVE_, unx)      &&
         SIZEOF(CYG_DRIVE_) - 1 + 1 <= len  &&
         ISALPHA(drv = ((unsigned char *)unx)[SIZEOF(CYG_DRIVE_) - 1])  &&
         (SIZEOF(CYG_DRIVE_) - 1 + 1 == len || '/' == unx[SIZEOF(CYG_DRIVE_)])
        )  {
d118 2
a119 2
        i = SIZEOF(CYG_DRIVE_);
        j = (SIZEOF(CYG_DRIVE_) - 1 + 1 == len) ? 3 : 2;
d140 2
a141 1
# undef CYG_DRIVE_
@
