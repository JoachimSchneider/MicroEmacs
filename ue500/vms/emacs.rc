;       EMACS.RC:       Standard MicroEMACS Startup program
;                       for MicroEMACS 3.13 and above
;                       (C)opyright 1987-99 by Daniel M Lawrence
;                       Last Update: 11/13/93

;;
; `set $palette "CLRMAP  ...' *doesn't* work with ANSI and VMS SMG
; terminal driver.
;;
; tput setf [1-7]
; tput setb [1-7]
;;
; Foreground
;set $palette "CLRMAP  0 ~e[30m" ; black
;set $palette "CLRMAP  1 ~e[31m" ; red
;set $palette "CLRMAP  2 ~e[32m" ; green
;set $palette "CLRMAP  3 ~e[33m" ; yellow
;set $palette "CLRMAP  4 ~e[34m" ; blue
;set $palette "CLRMAP  5 ~e[35m" ; magenta
;set $palette "CLRMAP  6 ~e[36m" ; cyan
;set $palette "CLRMAP  7 ~e[37m" ; white
; Background
;set $palette "CLRMAP  8 ~e[40m" ; black
;set $palette "CLRMAP  9 ~e[41m" ; red
;set $palette "CLRMAP 10 ~e[42m" ; green
;set $palette "CLRMAP 11 ~e[43m" ; yellow
;set $palette "CLRMAP 12 ~e[44m" ; blue
;set $palette "CLRMAP 13 ~e[45m" ; magenta
;set $palette "CLRMAP 14 ~e[46m" ; cyan
;set $palette "CLRMAP 15 ~e[47m" ; white
;;

;;
; Definition of escape sequences generated by e.g. funktion keys.
; The key-names are fixed (see stock() in bind.c). Use '~~' to
; mask a literal '~'.
;;
; FN1 -- FN4 did not work with TERM=xterm and RXVT
;;
set $palette "KEYMAP FN1 ~eOP"
set $palette "KEYMAP FN2 ~eOQ"
set $palette "KEYMAP FN3 ~eOR"
set $palette "KEYMAP FN4 ~eOS"
set $palette "KEYMAP FN1 ~e[11~~"
set $palette "KEYMAP FN2 ~e[12~~"
set $palette "KEYMAP FN3 ~e[13~~"
set $palette "KEYMAP FN4 ~e[14~~"
set $palette "KEYMAP FN5 ~e[15~~"
set $palette "KEYMAP FN6 ~e[17~~"
set $palette "KEYMAP FN7 ~e[18~~"
set $palette "KEYMAP FN8 ~e[19~~"
set $palette "KEYMAP FN9 ~e[20~~"
set $palette "KEYMAP FN0 ~e[21~~"
; HOME  (`~e[H': needed by VMS)
set $palette "KEYMAP FN< ~e[H"
set $palette "KEYMAP FN< ~e[7~~"
;;
set $palette "KEYMAP S-FN1 ~e[25;2~~"
set $palette "KEYMAP S-FN2 ~e[26;2~~"
set $palette "KEYMAP S-FN3 ~e[28;2~~"
set $palette "KEYMAP S-FN4 ~e[29;2~~"
set $palette "KEYMAP S-FN5 ~e[31;2~~"
set $palette "KEYMAP S-FN6 ~e[32;2~~"
set $palette "KEYMAP S-FN7 ~e[33;2~~"
set $palette "KEYMAP S-FN8 ~e[34;2~~"
set $palette "KEYMAP S-FN9 ~e[42;2~~"
set $palette "KEYMAP S-FN0 ~e[43;2~~"
; Not (yet) possible:
;set $palette "KEYMAP S-FN11 ~e[44;2~~"
;set $palette "KEYMAP S-FN12 ~e[45;2~~"
;;

set $discmd FALSE
write-message "[Setting up....]"

; Uncomment this line if writing of a file should use these steps
;  (i) Write to temporary file
; (ii) Move temporary file to edited file
; This mode (default on other platforms) will disable VMS file
; versions --- so be careful!
;       set $ssave  "TRUE"

; If you screen "SNOWS", comment this line
        set $flicker "FALSE"

; To use an IBM-PC EGA card, uncomment the following line
;       set $sres "EGA"

;       If you hate clocks or position counters, comment these
set $timeflag TRUE
set $posflag TRUE

;;
; What is a paragraph:
;;
;
; Set the word characters: This makes e.g. "fill-paragraph" work with TeX-Files:
set $wchars "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+{}[]\\|;:\"'<>,./?~`"
; Default paragraph indent used with fill-*
set $parindent 0
; Default is " \t" which means that indents are recognized as BOP.
set $paralead ""
;;

;       Set Default Global modes

;add-global-mode "blue"
;add-global-mode "WHITE"
;bind-to-key meta-prefix `      ;for annoying keyboards with ` at the top left

;       Toggle function key window display

set %FKEYS  "Function Keys"
store-procedure toggle-fkeys
        !if %rcfkeys
                !goto rcfoff
        !endif

;       toggle function key window on
        save-window
        1 next-window
        !if &sequal $cbufname "emacs.hlp"
                delete-window
        !endif
        !if &not &sequal $cbufname %FKEYS
                1 split-current-window
                1 select-buffer %FKEYS
                ;add-mode "red"
                !force 5 resize-window
                1 goto-line
        !endif
        set %rcfkeys TRUE
        !force restore-window
        !if &sequal $cbufname %FKEYS
                next-window
        !endif
        write-message "[Function key window ON]"
        !return

        ;Toggle the function key window off
*rcfoff
        save-window
        1 next-window
        !if &sequal %FKEYS $cbufname
                delete-window
        !endif
        !force restore-window
        write-message "[Function key window OFF]"
        set %rcfkeys FALSE
!endm

;       Bring up Online-help system

store-procedure get-help
        set $discmd FALSE
        source ehelp.cmd
        set $discmd TRUE
!endm

;       Load a new page

store-procedure get-page-loader
        !if &seq &find newpage.cmd ""
                write-message "[Can not find NEWPAGE.CMD]"
                !return
        !endif
        execute-file newpage.cmd
!endm

;procedure to clean out the current page (which is nothing right now)

store-procedure clean
        ; nothing by default
!endm

;       Set up auto CMODE

store-procedure set-default-mode
        set %rctmp &sin $cfname "."
        !if &equ %rctmp 0
                !return
        !endif
        set %rctmp &mid $cfname &add %rctmp 1 5
        !if &or &seq %rctmp "c" &seq %rctmp "h"
                add-mode "cmode"
        !endif
        !if &or &seq %rctmp "cpp" &seq %rctmp "hpp"
                add-mode "cmode"
        !endif
        !if &or &seq %rctmp "mss" &seq %rctmp "txt"
                add-mode "wrap"
        !endif
!endm
set $readhook set-default-mode

;       This function activates the function key window as
;       a legitimate place to call up function keys using the mouse

store-procedure mouse-clicks

        ;remember where we started, and do the mouse movement
        save-window
        !force mouse-move-down

        ;If not in the function key window... leave
        !if &not &sequal $cbufname %FKEYS
                !return
        !endif

        ;First pos is a screen reposition, let it through
        !if &and &equ $xpos 0 &equ $ypos 0
                restore-window
                !return
        !endif

        ;Find out what function key were gonna do
        add-mode magic
        2 forward-character
        set %rctmp $search
        !force search-reverse "[fF][0-9]"
        !if &seq $status FALSE
                delete-mode magic
                set $search %rctmp
                !return
        !endif

        ;we are on the "f" or "F".  Get the function key type and number now
        set $search %rctmp
        set %fcase lower
        !if &equ $curchar 70
                set %fcase upper
        !endif
        1 forward-character
        set %fnum &chr $curchar
        1 forward-character
        set %fnum &cat %fnum &chr $curchar
        set %fnum &add %fnum 0
        !if &equ %fnum 10
                set %fnum "0"
        !endif
        set %fname &cat "FN" %fnum
        !if &seq %fcase upper
                set %fname &cat "S-" %fname
        !endif

        ;save the function
        set %rccmd &bind %fname
        delete-mode MAGIC

        ;swallow the up-button
        set %rctmp &gtc

        ;restore the window and exit
        restore-window

        ;procedures don't need the square brackets
        !if &seq &left %rccmd 1 "["
                set %rccmd &mid %rccmd 2 &sub &len %rccmd 2
                %rccmd
                !return
        !endif

        ;and then execute it
        !force execute-named-command %rccmd
!endm
macro-to-key mouse-clicks MSa

;       ***** Rebind the Function key group

; ANSI and VMS SMG give FN^[1-4] ... instead of FN[1-4]
bind-to-key search-forward              FN^1
bind-to-key search-reverse              FN^2
bind-to-key hunt-forward                FN^3
bind-to-key hunt-backward               FN^4
bind-to-key search-forward              FN1
bind-to-key search-reverse              FN2
bind-to-key hunt-forward                FN3
bind-to-key hunt-backward               FN4
macro-to-key toggle-fkeys               FN5
macro-to-key get-help                   FN6
bind-to-key next-window                 FN7
macro-to-key get-page-loader            FN8
bind-to-key save-file                   FN9
bind-to-key exit-emacs                  FN0

;       bring up the function key window

        1 split-current-window
        1 select-buffer %FKEYS
        insert-string "f1 search-> f2 <-search |    MicroEMACS:  Text Editor~n"
        insert-string "f3 hunt->   f4 <-hunt   | ~n"
        insert-string "f5 fkeys    f6 help     |  Available function key Pages include:~n"
        insert-string "f7 nxt wind f8 pg[    ] |    Word  Box  Emacs  Pascal  C  cObol Lisp~n"
        insert-string "f9 save     f10 exit    |  [use the f8 key to load Pages]~n"
        unmark-buffer
        delete-window
        set %rcfkeys FALSE

        !if &seq $os "UNIX"

                ;Allow mainframes to simulate function
                ;keys with ^C<n> and ^C shifted-<n>

                store-procedure emulate-fkeys
                        !if &not $pending
                                write-message "FN-"
                        !endif
                        set %rcchar &gtkey
                        set %rcchar &sindex "1234567890!@#$%^&*()" %rcchar
                        !if &equ %rcchar 0
                                write-message "[Not Bound]"
                                !return
                        !endif
                        clear-message-line
                        set %rctmp "FN"
                        !if &gre %rcchar 10
                                set %rctmp &cat "S-" %rctmp
                        !endif
                        set %rcchar &mid "12345678901234567890" %rcchar 1
                        set %rctmp &bind &cat %rctmp %rcchar
                        !if &seq &lef %rctmp 1 "["
                                set %rctmp &mid %rctmp 2 &sub &len %rctmp 2
                                run %rctmp
                                !return
                        !endif
                        !force execute-named-command %rctmp
                !endm

                macro-to-key emulate-fkeys ^C

        !endif

        !if &seq $os "MSWIN"
                source "mewin.cmd"
        !else
                toggle-fkeys
        !endif

!if &seq $os "OS2"
        set $sres VGA
        set $sres CGA
!endif

        set $discmd TRUE

;===============================================================================
; Local additions
;===============================================================================
store-procedure redraw-screen
        clear-and-redraw
        execute-procedure toggle-fkeys
!endm
; ^L was originally bound to clear-and-redraw
macro-to-key redraw-screen ^L

store-procedure out-tab
        insert-string "~t"
!endm
; ^T was originally bound to transpose-characters
macro-to-key out-tab ^T

2 handle-tab
set $softtab 2
set $hardtab 8
bind-to-key set-mark ^@
set $dispundo TRUE
; turn off highlighting:
set $hilight 255
;===============================================================================


;===============================================================================
; German Umlauts (in ISO-8859-1):
;===============================================================================
store-procedure german-umlaut-ae
        insert-string "ä"
!endm
macro-to-key german-umlaut-ae M-a

store-procedure german-umlaut-oe
        insert-string "ö"
!endm
macro-to-key german-umlaut-oe M-o

store-procedure german-umlaut-ue
        insert-string "ü"
!endm
macro-to-key german-umlaut-ue M-u
; was bound to M-u previously
bind-to-key case-word-upper M-p

store-procedure german-umlaut-sz
        insert-string "ß"
!endm
macro-to-key german-umlaut-sz M-s

store-procedure german-umlaut-ae
        insert-string "ä"
!endm
macro-to-key german-umlaut-ae M-a

store-procedure german-umlaut-Ae
        insert-string "Ä"
!endm
macro-to-key german-umlaut-Ae M-^A

store-procedure german-umlaut-Oe
        insert-string "Ö"
!endm
macro-to-key german-umlaut-Oe M-^O

store-procedure german-umlaut-Ue
        insert-string "Ü"
!endm
macro-to-key german-umlaut-Ue M-^U
;===============================================================================



;;
; EOF
;;
